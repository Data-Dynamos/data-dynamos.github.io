"use strict";(self.webpackChunkdata_dynamos_github_io=self.webpackChunkdata_dynamos_github_io||[]).push([[4325],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var r=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(a),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||n;return a?r.createElement(h,o(o({ref:t},u),{},{components:a})):r.createElement(h,o({ref:t},u))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,o=new Array(n);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<n;p++)o[p]=a[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9986:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>l,toc:()=>p});var r=a(7462),i=(a(7294),a(3905));const n={sidebar_position:8},o="Spark Workflow and Partitioning",l={unversionedId:"spark/spark-workflow-and-partitioning",id:"spark/spark-workflow-and-partitioning",title:"Spark Workflow and Partitioning",description:"Optimisation",source:"@site/docs/spark/spark-workflow-and-partitioning.mdx",sourceDirName:"spark",slug:"/spark/spark-workflow-and-partitioning",permalink:"/docs/spark/spark-workflow-and-partitioning",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/spark/spark-workflow-and-partitioning.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Want to learn more about the Spark UI?",permalink:"/docs/spark/learn-more-about-the-spark-ui"},next:{title:"Exercise: Core Logic",permalink:"/docs/spark/exercise-core-logic"}},s={},p=[{value:"Optimisation",id:"optimisation",level:2},{value:"Partitioning",id:"partitioning",level:2},{value:"Working with Partitioned Data",id:"working-with-partitioned-data",level:2},{value:"Partitioning FAQs",id:"partitioning-faqs",level:2},{value:"Shuffling",id:"shuffling",level:2},{value:"Resources",id:"resources",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"spark-workflow-and-partitioning"},"Spark Workflow and Partitioning"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("figure",{class:"video-container"},(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/rx-J34dKYUc",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))),(0,i.kt)("h2",{id:"optimisation"},"Optimisation"),(0,i.kt)("p",null,"Okay...I know how to wrangle/transform my data...but how do I actually optimize my job\u2019s performance?\nGolden Rule: In the real world, make sure your dataset/table is partitioned well"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Lots of small files are the enemy!",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Having lots of tiny files will result in S3 needing to do lots of ",(0,i.kt)("strong",{parentName:"li"},"file listing")," operations. These are extremely slow and can even be expensive"),(0,i.kt)("li",{parentName:"ul"},"Lots of small files means lots of data shuffling through the network. ",(0,i.kt)("strong",{parentName:"li"},"This is slow!")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"HUGE")," files are also bad",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Having too few files (all being huge) means you probably won\u2019t take advantage of all of the cores in your cluster. In other words, the data can\u2019t be easily distributed around the cluster"),(0,i.kt)("li",{parentName:"ul"},"Each node in your cluster might even have to try and break down each of these huge files in order to redistribute some data to other nodes. This is a waste of time and money (",(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=982wFqC03v8&ab_channel=pyromaniack"},"must-watch"),")"))),(0,i.kt)("li",{parentName:"ul"},"So what\u2019s a suitable strategy?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"There\u2019s no \u2018best\u2019 number. Try to target each .snappy.parquet file to be somewhere ",(0,i.kt)("strong",{parentName:"li"},"roughly between 256MB to 1GB")),(0,i.kt)("li",{parentName:"ul"},"More importantly, make sure that you\u2019re partitioning on columns that you frequently ",(0,i.kt)("strong",{parentName:"li"},"filter")," or do ",(0,i.kt)("strong",{parentName:"li"},"groupBy")," on"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DO NOT")," partition on columns with high cardinality (e.g. a userId, which has millions of distinct values)\nthis will result in lots of ",(0,i.kt)("strong",{parentName:"li"},"small files and lots of file listing operations"))))),(0,i.kt)("h2",{id:"partitioning"},"Partitioning"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"partitioning.png",src:a(7e3).Z,width:"379",height:"477"}))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Partitioning strategy is the most important decision we have to get right!")),(0,i.kt)("p",null,"If your partitioning strategy is decent, you\u2019ll most likely be fine and won\u2019t need to tweak other knobs.\nEspecially going forward in the future with Spark 3.0\u2019s ",(0,i.kt)("a",{parentName:"p",href:"https://databricks.com/blog/2020/05/29/adaptive-query-execution-speeding-up-spark-sql-at-runtime.html"},"Adaptive Query Execution (AQE)"),", a lot of optimizations will be automated for you!"),(0,i.kt)("p",null,"So how does a partitioned table look?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It would actually look like a bunch of hierarchical folders"),(0,i.kt)("li",{parentName:"ul"},"The partitioning values become their own folder (e.g. year=2018)"),(0,i.kt)("li",{parentName:"ul"},"The underlying data will be at the bottom of the hierarchy and will"),(0,i.kt)("li",{parentName:"ul"},"often have a .snappy.parquet file extension (if using Spark)")),(0,i.kt)("p",null,"Can you give me an example?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Partitioning the table based on some notion of time is a popular option\n(check if that makes sense for your project first though!)"),(0,i.kt)("li",{parentName:"ul"},"e.g. assuming each day of data for the table is of the order of 128MB - 1GB, then\nyour partitioning keys can be (\u201cyear\u201d, \u201cmonth\u201d, \u201cday\u201d)"),(0,i.kt)("li",{parentName:"ul"},"You don\u2019t need to explicitly define all the values, Spark will smartly\ncreate a new partition for each distinct combination of your partitioning values")),(0,i.kt)("h2",{id:"working-with-partitioned-data"},"Working with Partitioned Data"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("figure",{class:"video-container"},(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/fhEJG2oFCm8",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))),(0,i.kt)("h2",{id:"partitioning-faqs"},"Partitioning FAQs"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"partitioning.png",src:a(7e3).Z,width:"379",height:"477"}))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"}," Question: So...is a parquet file a file or a folder of files?")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Short Answer: either!")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"With a single-node library like Pandas, you can write a single .snappy.parquet file if you want"),(0,i.kt)("li",{parentName:"ul"},"However, in the real-world they are often folders of partitions",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This way you can read/write an entire table with just one path (the root of the table)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"e.g. s3://my-bucket/my-table/ or s3://my-bucket/my-table.parquet/ (both of these styles are still folders)"),(0,i.kt)("li",{parentName:"ul"},"Underneath all of the partitioning folders, you will find your .snappy.parquet files"))),(0,i.kt)("li",{parentName:"ul"},"The query engine (e.g. Spark or Presto) will then take care of understanding the partitioning structure of the table and will optimize your queries around that"),(0,i.kt)("li",{parentName:"ul"},"Spark will always write the output of a DataFrame as a folder at the root level rather than a single file (because it\u2019s designed for distributed/concurrent reading/writing of data, which often involves multiple files)")))),(0,i.kt)("h2",{id:"shuffling"},"Shuffling"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"shuffling.png",src:a(4467).Z,width:"424",height:"512"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://blog.scottlogic.com/2018/03/22/apache-spark-performance.html#:~:text=A%20shuffle%20occurs%20when%20data,likely%20on%20a%20different%20executor."},"Reference"))),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"fear-path-to-dark-side.png",src:a(4055).Z,width:"512",height:"288"}))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.rockthejvm.com/spark-dags/"},"Spark DAGs and planning")," (optional)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Just know that bad partitioning \u2192 shuffling \u2192 pain (must-watch)"),(0,i.kt)("li",{parentName:"ul"},"You can check how \u2018shuffly\u2019 your Spark job looks by viewing the DAG"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://mungingdata.com/apache-spark/partitionby/"},"Managing Partitioning"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Important: understand that repartition() and DataFrame.write.partitionBy() are ",(0,i.kt)("strong",{parentName:"li"},"not")," the same thing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Repartition can take in 2 different types of arguments:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"a number: controls the number of .snappy.parquet files"),(0,i.kt)("li",{parentName:"ul"},"a bunch of column names: it will ensure 1 .snappy.parquet file per each distinct combination of your provided columns"))),(0,i.kt)("li",{parentName:"ul"},"DataFrame.write.partitionBy defines the folder structure of the table ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"however, it does not guarantee how many .snappy.parquet files will be in each folder "))),(0,i.kt)("li",{parentName:"ul"},"Sometimes you might even need to do both e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"df.repartition(\u201cyear\u201d, \u201cmonth\u201d).write.partitionBy(\u201cyear\u201d, \u201dmonth\u201d)...")," in order to guarantee exactly 1 .snappy.parquet file per each month folder"))),(0,i.kt)("li",{parentName:"ul"},"Try to read up on the difference between repartition and coalesce ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Short Answer: ",(0,i.kt)("a",{parentName:"li",href:"https://spark.apache.org/docs/2.1.0/api/python/pyspark.sql.html#pyspark.sql.DataFrame.coalesce"},"The coalesce transformation applied to a DataFrame")," (not to be confused with ",(0,i.kt)("a",{parentName:"li",href:"https://spark.apache.org/docs/latest/api/python//reference/pyspark.sql/api/pyspark.sql.functions.coalesce.html"},"coalesce() applied to a column"),"), will try to merge partitions to reach your desired number. You only use coalesce when you want to reduce the number of partitions in your data."),(0,i.kt)("li",{parentName:"ul"},"On the other hand, repartition() will full shuffle all of the data around (more expensive)."),(0,i.kt)("li",{parentName:"ul"},"If you need to increase the number of partitions in your data, then you will need repartition()"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/data-derp/small-exercises/blob/master/databricks-repartition-vs-write-partition-by.dbc"},"Practice Repartitioning vs PartitionBy in DataBricks"))))}d.isMDXComponent=!0},4055:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/fear-path-to-dark-side-02df5aba18d3a6b7209b559ad8883194.png"},7e3:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/partitioning-ac6b6c56d48894919e4f9058a0a8ab9c.png"},4467:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/shuffling-ed3cfadd55c02ea6dddadb4cb0f42f96.png"}}]);